"""Configuration controller for managing Ampio configuration."""

import asyncio

from pathlib import Path
from typing import TYPE_CHECKING, Generic

import yaml

from aioampio.codec.registry import registry
from aioampio.controllers.base import AmpioResource
from ..models.config import BinarySensorCfg, CodecCfg, Config, CoverCfg, DeviceCfg, LightCfg, OutputCfg, SensorCfg, PlatformCfg

if TYPE_CHECKING:
    from ..bridge import AmpioBridge



class ConfigController(Generic[AmpioResource]):
    """
    Manages the configuration of the Ampio bridge.
    """
    
    def __init__(self, bridge: "AmpioBridge") -> None:
        self._bridge = bridge
        self._config: Config | None = None
        self._items: dict[str, AmpioResource] = {}
        self._logger = bridge.logger.getChild("Config")

    async def initialize(self, cfg_path: str) -> None:
        conf = await read_text(cfg_path)
        data = yaml.safe_load(conf)

        # from aioampio.bridge import AmpioBridge  # to avoid circular import
        # Config.model_rebuild()
        # ctx ={'bridge': self._bridge}
        self._config = Config.model_validate(data)
        self._logger.info("Loaded configuration from %s", cfg_path)
        
        await registry().load_modules([c.module for c in self._config.codecs])

        self._process_config()
        exit()

    def _process_config(self) -> None:
        if not self._config:
            return
        for device in self._config.devices:
            print(device)

            print()
        # # Index entities by platform and id
        # for can_id, device in self._config.devices.items():
        #     for entity in device.binary_sensors:
        #         self._items[entity.id] = entity
        #     for entity in device.sensors:
        #         self._items[entity.id] = entity
        #     for entity in device.lights:
        #         self._items[entity.id] = entity
        #     for entity in device.covers:
        #         self._items[entity.id] = entity


        self._logger.info("Processed configuration: %d devices, %d entities",
                          len(self._config.devices),
                          len(self._items))


    @property
    def devices(self) -> dict[int, DeviceCfg]:
        return self._config.devices

    @property
    def outputs(self) -> list[OutputCfg]:
        """Return all output entities."""
        return self._config.outputs

    @property
    def codecs(self) -> list[CodecCfg]:
        """Return all codec entities."""
        return self._config.codecs


    def _iter_entities(self, attr: str):
        for can_id, device in self.devices.items():
            for entity in getattr(device, attr, []):
                # entity.can_id = can_id
                yield entity

    @property
    def lights(self) -> list[LightCfg]:
        """Return all light entities."""
        return list(self._iter_entities("lights"))

    @property
    def sensors(self) -> list[SensorCfg]:
        """Return all sensor entities."""
        return list(self._iter_entities("sensors"))

    @property
    def binary_sensors(self) -> list[BinarySensorCfg]:
        """Return all binary sensor entities."""
        return list(self._iter_entities("binary_sensors"))

    @property
    def covers(self) -> list[CoverCfg]:
        """Return all cover entities."""
        return list(self._iter_entities("covers"))
    
    @property
    def entities(self) -> list[PlatformCfg]:
        """Return all platform entities."""
        return list(self._config.all_platforms()) if self._config else []

